---
title: "Laboratorio 2"
author: "Estadistica descriptiva multivariada"
institute: UNAL - Departamento de estadÃ­stica
date: today
date-format: "dddd, D [de] MMMM, YYYY"
lang: es
format: 
  revealjs:
    theme: serif
    embed-resources: true
echo: true
code-fold: true
code-summary: ""
---

## [Autores]{style="color:#9932CC"}

-   Caballero Gutierrez David Santiago
-   CastaÃ±o Suaza Carlos Mario
-   Martinez Cardenas Maria Fernanda
-   Matallana Fiquitiva Thomas Felipe
-   Paez Molina Diego Andres
-   Sanchez Guarnizo Leidy Tatiana

## [Punto 1]{style="color:#9932CC"}

El vector de medias de todas las variables.

```{r, fig.align = 'center'}
library(readxl)
library(kableExtra)

# Cargar y renombrar las columnas
Ciudades <- read_excel("Ciudades.xlsx")
colnames(Ciudades)[colnames(Ciudades) == "RH_1"] <- "PC"
colnames(Ciudades)[colnames(Ciudades) == "RH_2"] <- "TCP"
colnames(Ciudades)[colnames(Ciudades) == "RH_5"] <- "AA"
colnames(Ciudades)[colnames(Ciudades) == "RH_6"] <- "CBPS"
colnames(Ciudades)[colnames(Ciudades) == "RH_7"] <- "CBES"
colnames(Ciudades)[colnames(Ciudades) == "RH_8"] <- "RAP"
colnames(Ciudades)[colnames(Ciudades) == "RH_9"] <- "CC"
colnames(Ciudades)[colnames(Ciudades) == "RH_10"] <- "CPT"
colnames(Ciudades)[colnames(Ciudades) == "RH_11"] <- "CS"
colnames(Ciudades)[colnames(Ciudades) == "RH_12"] <- "MI"
colnames(Ciudades)[colnames(Ciudades) == "RH_13"] <- "DCFS"
colnames(Ciudades)[colnames(Ciudades) == "RH_14"] <- "VI"
colnames(Ciudades)[colnames(Ciudades) == "RH_15"] <- "H"
colnames(Ciudades)[colnames(Ciudades) == "RH_16"] <- "S"

# Calcular las medias
med <- round(t(colMeans(Ciudades[, 2:15])), 2)
med <- as.data.frame(round(colMeans(Ciudades[, 2:15]), 2))
colnames(med) <- c("Media")

# Centrar la tabla y ajustar el tamaÃ±o
med %>%
  kable("html") %>%
  kable_styling("basic", full_width = FALSE, position = "center") %>%
  kable_styling(font_size = 18) %>%
  column_spec(1, bold = TRUE) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  row_spec(0, bold = TRUE)

```

## [Punto 1]{style="color:#9932CC"}

-   Â¿CuÃ¡l es la variable que tiene la menor media? La variable que tiene mayor media es la PoblaciÃ³n de la ciudad (PC).

-   Â¿CuÃ¡l es la variable que tiene la menor media? La variable que tiene la menor media es la Tasa de Crecimiento de la PoblaciÃ³n (TCP)

## [Punto 1]{style="color:#9932CC"}

-   Â¿A quÃ© puede atribuirse la diferencia en los valores de los dos promedios? La diferencia en los valores de los promedios puede atribuirse a las unidades que representan las variables. En este caso, la Poblacion de la ciudad (PC) tiene una media de 888021,77, lo que indica que se trata de una variable en una escala mucho mayor (poblaciÃ³n), ya que se trata de el nÂ´umero de personas. Por otro lado, la Tasa de Crecimiento de la PoblaciÃ³n (TCP) tiene una media de 0,01 que representa una tasa o proporciÃ³n, lo que explica su menor valor promedio.

## [Punto 2]{style="color:#9932CC"}

Calcular la matriz Y de datos centrados y estandarizado.

```{r}
library(readxl)
Ciudades <- read_excel("Ciudades.xlsx")
colnames(Ciudades)[colnames(Ciudades) == "RH_1"] <- "PC"
colnames(Ciudades)[colnames(Ciudades) == "RH_2"] <- "TCP"
colnames(Ciudades)[colnames(Ciudades) == "RH_5"] <- "AA"
colnames(Ciudades)[colnames(Ciudades) == "RH_6"] <- "CBPS"
colnames(Ciudades)[colnames(Ciudades) == "RH_7"] <- "CBES"
colnames(Ciudades)[colnames(Ciudades) == "RH_8"] <- "RAP"
colnames(Ciudades)[colnames(Ciudades) == "RH_9"] <- "CC"
colnames(Ciudades)[colnames(Ciudades) == "RH_10"] <- "CPT"
colnames(Ciudades)[colnames(Ciudades) == "RH_11"] <- "CS"
colnames(Ciudades)[colnames(Ciudades) == "RH_12"] <- "MI"
colnames(Ciudades)[colnames(Ciudades) == "RH_13"] <- "DCFS"
colnames(Ciudades)[colnames(Ciudades) == "RH_14"] <- "VI"
colnames(Ciudades)[colnames(Ciudades) == "RH_15"] <- "H"
colnames(Ciudades)[colnames(Ciudades) == "RH_16"] <- "S"
Xtil<-scale(Ciudades[,2:15], scale = T)
# Redondear la matriz 'Xtil' a 2 decimales
Xtil_redondeadas <- round(Xtil, 2)
print(Xtil_redondeadas)
```

## [Punto 2]{style="color:#9932CC"}

La diferencia entre las medias se debe a que al estandarizar los datos esto garantiza que el vector de medias va a ser un vector de ceros, por lo tanto, al calcular el vector de medias con los datos sin estandarizar estamos la tendencia central en la escala normal, pero al estandarizarlo vamos a tener medias de cero.

## [Punto 3]{style="color:#9932CC"}

La matriz de covarianzas muestra la variaciÃ³n compartida entre pares de variables. Identificar las mayores y menores covarianzas permite entender cuÃ¡les variables tienen mayor y menor relaciÃ³n en tÃ©rminos de variabilidad conjunta.

```{r}
Ciudades_numeric <- Ciudades[, sapply(Ciudades, is.numeric)]

# Calcular la matriz de covarianzas
S <- cov(Ciudades_numeric)
S <- round(S, 2)

# Convertir la matriz de covarianzas en formato largo y omitir la diagonal
covarianzas <- as.data.frame(as.table(S))
covarianzas <- covarianzas[covarianzas$Var1 != covarianzas$Var2, ]

# Identificar las dos mayores y menores covarianzas
mayor_cov <- head(covarianzas[order(-covarianzas$Freq), ], 2)
menor_cov <- head(covarianzas[order(covarianzas$Freq), ], 2)

# Resultados
cat("Matriz de covarianzas S:\n")
print(S)

```

## [Punto 3]{style="color:#9932CC"}

```{r}
cat("\nLas dos variables con mayor covarianza son:\n")
print(mayor_cov)
```

```{r}
cat("\nLas dos variables con menor covarianza son:\n")
print(menor_cov)
```

## [Punto 4]{style="color:#9932CC"}

La matriz de correlaciÃ³n ð‘… mide la relaciÃ³n lineal entre pares de variables, sin depender de sus escalas.

```{r}
# Calcular la matriz de correlaciÃ³n
R <- cor(Ciudades_numeric)
R <- round(R, 2)

# Convertir la matriz de correlaciÃ³n en formato largo y omitir la diagonal
correlaciones <- as.data.frame(as.table(R))
correlaciones <- correlaciones[correlaciones$Var1 != correlaciones$Var2, ]

# Identificar las dos mayores y menores correlaciones
mayor_cor <- head(correlaciones[order(-abs(correlaciones$Freq)), ], 2)
menor_cor <- head(correlaciones[order(abs(correlaciones$Freq)), ], 2)
```

```{r}
cat("Matriz de correlaciÃ³n R:\n")
print(R)
```

## [Punto 4]{style="color:#9932CC"}

```{r}
cat("\nLas dos variables con mayor correlaciÃ³n son:\n")
print(mayor_cor)
```

```{r}
cat("\nLas dos variables con menor correlaciÃ³n son:\n")
print(menor_cor)
```

## [Punto 5]{style="color:#9932CC"}

El producto Y\texttt{â€²}Y al ser calculado sobre variables estandarizadas, deberÃ­a coincidir con la matriz de correlaciÃ³n ð‘…. Esto sucede porque la estandarizaciÃ³n normaliza las variables, permitiendo que sus covarianzas se transformen directamente en correlaciones.

```{r,  include=FALSE}
# Estandarizar la matriz de datos RH
Y <- scale(Ciudades_numeric)

# Calcular el producto Y'Y
YtY <- t(Y) %*% Y / (nrow(Y) - 1)
YtY <- round(YtY, 2)
```

```{r}
cat("Producto Y'Y:\n")
print(YtY)
cat("\nMatriz de correlaciÃ³n R:\n")
print(R)
```

```{r}
# Verificar si Y'Y es igual a R
identico <- all.equal(YtY, R)
cat("\nÂ¿Es Y'Y igual a R? ", identico, "\n")
```

## [Punto 6]{style="color:#9932CC"}

Utilizar el archivo ciudades para construir un indicador de Recursos Humanos IRH con las variables Tasa de Crecimiento de la PoblaciÃ³n, Analfabetismo Absoluto, Cobertura bruta en educaciÃ³n superior, RelaciÃ³n alumno-profesor, Calidad de los colegios, Mortalidad Infantil con las siguientes ponderaciones bâ€² = (0,82, 0,89, âˆ’0,56, 0,77, âˆ’0,69, 0,64) respectivamente.

Al observar la tabla con las variables, nos damos cuenta que no estan medidas en la misma escala, por lo tanto se estandarizan las variables

## [Punto 6]{style="color:#9932CC"}

Estandarizamos las variables y nos queda la siguiente tabla:

```{r}
#Importamos la tabla
library(readxl)
Indicador <- read_excel("Indicador.xlsx")
colnames(Indicador)[colnames(Indicador) == "RH_2"] <- "TCP"
colnames(Indicador)[colnames(Indicador) == "RH_5"] <- "AA"
colnames(Indicador)[colnames(Indicador) == "RH_7"] <- "CBES"
colnames(Indicador)[colnames(Indicador) == "RH_8"] <- "RAP"
colnames(Indicador)[colnames(Indicador) == "RH_9"] <- "CC"
colnames(Indicador)[colnames(Indicador) == "RH_12"] <- "MI"

Indicador1 <- as.data.frame(Indicador[,-1])
rownames(Indicador1) <- Indicador$CIUDADES

#Estandarizamos las variables para que tenga sentido
Indicador_estandarizado <- as.data.frame(scale(Indicador1))
Indicador_estandarizado
```

## [Punto 6]{style="color:#9932CC"}

Realizamos el calculo de las combinaciones lineales para cada ciudad:

```{r}
# Realizamos las combinaciones lineales
ponderaciones <- c(0.82, 0.89, -0.56, 0.77, -0.69, 0.64)

# Crear un vector vacÃ­o para almacenar los resultados de las combinaciones lineales
combinaciones <- numeric(22)

# Calcular las combinaciones lineales
for (i in 1:22) {
  fila <- Indicador_estandarizado[i, ]
  combinacion <- sum(fila * ponderaciones)
  combinaciones[i] <- combinacion
}

# Crear un data frame con los resultados
resultado <- data.frame(Ciudad = rownames(Indicador_estandarizado), Combinacion = combinaciones)

# Mostrar la tabla centrada y con tamaÃ±o ajustado
resultado %>%
  kable("html") %>%
  kable_styling("basic", full_width = FALSE, position = "center") %>%
  kable_styling(font_size = 12) %>%   # TamaÃ±o de fuente ajustado
  column_spec(1, bold = TRUE) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  row_spec(0, bold = TRUE)

```

## [Punto 6]{style="color:#9932CC"}

por lo tanto, la tabla con el indicador de recursos humanos (IRH) nos quedaria asi:

```{r}
IRH <- c(-2.35115, -1.198219, -3.88349, -4.056861, -2.119058, 1.268714, 0.2948288, -0.4071047, -3.028496, 0.2934701, 3.479673, -0.0413025, -1.849455, -1.956823, -2.723258, 10.53961, -1.974952, 2.093005, 2.535739, -1.00447, 3.872996, 2.216603)
Indicador_estandarizado$IRH <- IRH
Indicador_estandarizado
```

## [Punto 7]{style="color:#9932CC"}

```{r}
library(readxl)
library(distances)
# Cargar y renombrar las columnas
Ciudades <- read_excel("Ciudades.xlsx")
colnames(Ciudades)[colnames(Ciudades) == "RH_1"] <- "PC"
colnames(Ciudades)[colnames(Ciudades) == "RH_2"] <- "TCP"
colnames(Ciudades)[colnames(Ciudades) == "RH_5"] <- "AA"
colnames(Ciudades)[colnames(Ciudades) == "RH_6"] <- "CBPS"
colnames(Ciudades)[colnames(Ciudades) == "RH_7"] <- "CBES"
colnames(Ciudades)[colnames(Ciudades) == "RH_8"] <- "RAP"
colnames(Ciudades)[colnames(Ciudades) == "RH_9"] <- "CC"
colnames(Ciudades)[colnames(Ciudades) == "RH_10"] <- "CPT"
colnames(Ciudades)[colnames(Ciudades) == "RH_11"] <- "CS"
colnames(Ciudades)[colnames(Ciudades) == "RH_12"] <- "MI"
colnames(Ciudades)[colnames(Ciudades) == "RH_13"] <- "DCFS"
colnames(Ciudades)[colnames(Ciudades) == "RH_14"] <- "VI"
colnames(Ciudades)[colnames(Ciudades) == "RH_15"] <- "H"
colnames(Ciudades)[colnames(Ciudades) == "RH_16"] <- "S"

Ciudad <- Ciudades[, c("CIUDADES", "AA", "RAP")]
Ciudad <- as.data.frame(Ciudad)

rownames(Ciudad)<-Ciudad$CIUDADES
X <- Ciudad[,-1]

# CÃ¡lculo de la distancia euclidiana
De <- distances(X, id_variable = row.names(X))
De <- round(as.matrix(De), 2)

# Mostrar la matriz de distancias
print(De)
```

## [Punto 7]{style="color:#9932CC"}

```{r}
# Convertir la matriz de distancias en un data frame
De_df <- as.data.frame(as.table(De))

# Eliminar los duplicados dejando solo la mitad superior de la matriz (sin la diagonal)
De_df <- De_df[upper.tri(De, diag = FALSE), ]

# Renombrar columnas del data frame
colnames(De_df) <- c("Ciudad 1", "Ciudad 2", "Distancia")

# Ordenar las distancias de mayor a menor
De_df <- De_df[order(-De_df$Distancia), ]

# Seleccionar las 2 ciudades mÃ¡s distantes
ciudades_mas_distantes <- head(De_df, 2)
colnames(ciudades_mas_distantes) <- c("a) MÃ¡s lejanas", " ", "Distancia")

# Seleccionar las 2 ciudades mÃ¡s cercanas
ciudades_mas_cercanas <- tail(De_df, 2)
colnames(ciudades_mas_cercanas) <- c("b) MÃ¡s cercanas", " ", "Distancia")

# Combinar las tablas de ciudades mÃ¡s lejanas y cercanas
ciud_lej_cerca <- cbind(ciudades_mas_distantes, ciudades_mas_cercanas)
ciud_lej_cerca
```

## [Punto 8]{style="color:#9932CC"}

```{r}
rownames(Ciudad)<-Ciudad$CIUDADES
Y <- Ciudad[,-1]

DiMah<-distances(Y, id_variable = row.names(Y),
                    normalize = "mahalanobize")
DiMah<-round(as.matrix(DiMah),2)
DiMah
```

## [Punto 8]{style="color:#9932CC"}
```{r}
# Convertir la matriz de distancias en un data frame
DiMah_df <- as.data.frame(as.table(DiMah))

# Eliminar los duplicados dejando solo la mitad superior de la matriz (sin la diagonal)
DiMah_df <- DiMah_df[upper.tri(De, diag = FALSE), ]

# Renombrar columnas del data frame
colnames(DiMah_df) <- c("Ciudad 1", "Ciudad 2", "Distancia")

# Ordenar las distancias de mayor a menor
DiMah_df <- DiMah_df[order(-DiMah_df$Distancia), ]

# Seleccionar las 2 ciudades mÃ¡s distantes
ciudades_distantes <- head(DiMah_df, 2)
colnames(ciudades_distantes) <- c("a) MÃ¡s lejanas", " ", "Distancia")

# Seleccionar las 2 ciudades mÃ¡s cercanas
ciudades_cercanas <- tail(DiMah_df, 2)
colnames(ciudades_cercanas) <- c("b) MÃ¡s cercanas", " ", "Distancia")

# Combinar las tablas de ciudades mÃ¡s lejanas y cercanas
ciud_lejos_cerca <- cbind(ciudades_distantes, ciudades_cercanas)
ciud_lejos_cerca
```
InterpretaciÃ³n: No, no son las mismas distancias que las obtenidas en el punto 7, esto se puede deber a que la distancia euclidiana no tomo en considerancion la correlaciÃ³n de las varaiables.

## [Punto 9]{style="color:#9932CC"}

Comprobar que la matriz de covarianzas se puede obtener con el producto 1/nXËœâ€²XËœ calcuandola a partir de la matriz de datos centrados de la matriz RH

```{r}
library(readxl)
RH <- read_excel("ciudades original-filtrado-con etiquetas - copia.xlsx",range=cell_cols(1:15))

colnames(RH)=c("Ciudades","PC", "TCP", "AA","CBPS","CBES","RAP","CC","CPT","CS","MI","DCFS","VI","H","S")

# Centrar las columnas de la subtabla RH
Xtil <- scale(RH[,2:15], scale = FALSE) 

n <- nrow(Xtil)

# Matriz de covarianzas calculada manualmente
cov_matrix_manual <- (1 / n) * t(Xtil) %*% Xtil  

# Matriz de covarianzas 
cov_matrix_R <- var(RH[,2:15])

#Comparacion 
all.equal(cov_matrix_manual, cov_matrix_R)

cat("Interpretacion:La diferencia en los resultados radica en que la funciÃ³n var() en R utiliza por defecto 1/(n-1) que es el estimador muestral para calcular la varianza de una variable cuantitativa.")

# Matriz de covarianzas ajustando el estimador muestral calculada manualmente)
cov_matrix_adjman <- (1 / (n-1)) * t(Xtil) %*% Xtil  

all.equal(cov_matrix_adjman, cov_matrix_R
```

## [Punto 10]{style="color:#9932CC"}

```{r}
Y <- scale(RH[, 2:15])
n <- nrow(Y)
MCor <- cor(RH[, 2:15])

Resultado1 <- 1 / n * t(Y) %*% Y
Resultado2 <- 1 / (n - 1) * t(Y) %*% Y  

all.equal(MCor, Resultado1)
all.equal(MCor, Resultado2)
```

# [Muchas gracias]{style="color:#9932CC"}
